video 1:
		Here is the notes guys hope it will hep you to save your time-

	*How JavaScript works?
	Ans-Everything in JavaScript happens inside an "execution context".

	Execution context has two component
	1)memory component[variable environment] 
	-This is the place where all variables and functions are stored as key value pairs. eg-{key: value ||  n:2;} 

	2)code component[Thread of execution]
	-This is the place where code is executed one line at a time

	Note-
	*JavaScript is a synchronous single-threaded language

	-Single threaded means JavaScript can execute once command at a time
	-Synchronous single-threaded that means JavaScript can execute one command at a time in a specific order.

	That whole thing is called as execution context inside that there two things 
	1.Memory component
	2.Code component
	In memory component variable and functions values can be stored in a  key value format.
	Code component is a place where whole JavaScript code is executed
	Memory component is also called as variable environment 
	And code component is also called as thread of execution.

video 2:
		Summary of this video - As we have already discussed in the last video that everything happens in javascript in the execution environment. So the entire execution happens in two phases as follows
	1. Memory allocation phase- all the variables  and functions get their memory allocated in the memory with undefined and the entire code  respectively. 
	2. Code execution phase - in this phase  thread execution happens and all the variables get their actual values which were assigned to them and as function is invoked, a new execution environment gets created in the code part, and again there are two phases, memory allocation phase and code execution phase. And the cycle repeats.

video 3:
	Things Learned:

	1. In JS, before the code is executed, the variables get initialized to undefined.
	2. Arrow functions enact as variables and get "undefined" during the memory creation phase while functions actually get run.
	3. Hoisting: Mechanism in JS where the variable declarations are moved to the top of the scope before execution. Therefore it is possible to call a function before initializing it.
	4. Whenever a JS program is run, a global execution block is created, which comprises of 2: Memory creation and Code execution.
	5. Variable declarations are scanned and are made undefined
	6. Function declarations are scanned and are made available

video 4:
	Summary:

	1. We learnt how functions work in JS.
	2. At first a global execution context is created, which consists of Memory and code and has 2 phases: Memory allocation phase and code execution phase.
	3. In the first phase, the variables are assigned "undefined" while functions have their own code.
	4. Whenever there is a function declaration in the code, a separate local execution context gets created having its own phases and is pushed into the call stack.
	5. Once the function ends, the EC is removed from the call stack.
	6. When the program ends, even the global EC is pulled out of the call stack.

video 5:
	Notes:
		• window object is created by the JS engines of the respective browsers when global execution context is created.
		• whenever an execution context is created a "this" variable is also created.
		• at the global level "this" points to the global object( window object in case of browsers).
		• anything that is not inside a function is the "global space".
		• whenever we create any variables or functions in the "global space", they get attached to the global object( window object in case of browsers).
		
		so to access the variables/function defined in the global space , 
		we can use any of the below:
			console.log(window.a);
			console.log(a);
			console.log(this.a)             //at the global space level, where this points to the window object

	Summary

	1. Shortest Program in JS: Empty file. Still, browsers make global EC and global space along with Window object.
	2. Global Space: Anything that is not in a function, is in the global space.
	3. Variables present in a global space can be accessed by a "window" object. (like window.a)
	4. In global space, (this === window) object.

video 6:
	1. Undefined is like a placeholder till a variable is not assigned a value.
	2. undefined !== not defined
	3. JS- weakly typed language since it doesn't depend on data type declarations.

video 7:
	Summary : 

	1. Scope of a variable is directly dependent on the lexical environment.
	2. Whenever an execution context is created, a lexical environment is created. Lexical environment is the local memory along with the lexical environment of its parent. Lexical as a term means in hierarchy or in sequence.
	3. Having the reference of parent's lexical environment means, the child or the local function can access all the variables and functions defined in the memory space of its lexical parent.
	4. The JS engine first searches for a variable in the current local memory space, if its not found here it searches for the variable in the lexical environment of its parent, and if its still not found, then it searches that variable in the subsequent lexical environments, and the sequence goes on until the variable is found in some lexical environment or the lexical environment becomes NULL.
	5. The mechanism of searching variables in the subsequent lexical environments is known as Scope Chain. If a variable is not found anywhere, then we say that the variable is not present in the scope chain.

video 8:
		Things learned:
	1. let and const are hoisted but its memory is allocated at other place than window which cannot be accessed before initialisation.
	2. Temporal Dead Zone exists until variable is declared and assigned a value.
	3. window.variable OR this.variable will not give value of variable defined using let or const.
	4. We cannot redeclare the same variable with let/const(even with using var the second time).
	5. const variable declaration and initialisation must be done on the same line.
	6. There are three types of error: [1] referenceError {given where variable does not have memory allocation} [2] typeError {given when we change type that is not supposed to be changed} [3] syntaxError {when proper syntax(way of writing a statement) is not used}.
	7. Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.
	8. Initialising variables at the top is good idea, helps shrinks TDZ to zero.

	so many things here. I would like to sum up in notes,

	-> let and const are hoisted. we cant use them before initialization is result of "temporal dead zone".
	-> js use diff memory than global execution context to store let and cost. which is reason behind "temporal dead zone"
	-> level of strictness ... var<<let<<const.
	-> var //no temporal dead zone, can redeclare and re-initialize, stored in GES
		let //use TDZ, can't re-declare, can re-initialize, stored in separate memory
		const //use TDZ, can't re-declare, can't re-initialize, stored in separate memory
	-> syntax error is similar to compile error. while type and reference error falls under run time error.
	-> syntax error ... violation of JS syntax
		type error ...  while trying to re-initialize const variable
		reference error ... while trying to access variable which is not there in global memory.

video 9:
	Things learned:
	1. Code inside curly bracket is called block.
	2. Multiple statements are grouped inside a block so it can be written where JS expects single statements like in if, else, loop, function etc.
	3. Block values are stored inside separate memory than global. They are stored in block. (the reason let and const are called block scope)
	4. Shadowing of variables using var, let and const.
	5. The shadow should not cross the scope of original otherwise it will give error.
	6. shadowing let with var is illegal shadowing and gives error.
	7. var value is stored in nearest outer function or global scope and hence can be accessed outside block as well whereas same is not the case with let and const.